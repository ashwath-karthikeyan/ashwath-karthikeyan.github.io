---
layout: post
title:  Rotary Inverted Pendulum
permalink: /rip/
date:   2023-12-30
image:  rip.png
tags:   [Control]
---
## Simulation of a Rotary Inverted Pendulum in Matlab-Simulink.

<center><img src="/img/rip.png" alt="RIP" height="400" width="400"></center> 
<br>

The rotary inverted pendulum problem is a popular control theory project, and it exemplifies a classic challenge in dynamic systems and control engineering. This system, also known as the Furuta Pendulum, involves a pendulum attached to the end of a rotating arm, where the primary goal is to control the arm's rotation to keep the pendulum balanced upright. It presents a real-time test of stabilization techniques, as it is inherently unstable and requires continuous feedback and adjustments to maintain equilibrium. The problem is widely used to demonstrate principles of linear and nonlinear control theory, including PID control and state space representation techniques.

### Developing the dynamic model

The design of this system is quite simple, and it consists of only two main parts and connecting components. It was modeled first in SolidWorks and then imported into Simulink using the Simscape Multibody toolbox. The various dimensions and parameters of the modeled system can either be taken note of at this point to be fed into the controller or conversely, they can be directly referenced from the XML file generated by the import. I have found the former to be simpler and easy to implement while not a very scalable method, but should suffice for this example.

### Modeling the system
First step for designing any controller is writing the equations of motion that define the system.

We write the equations of motion as:

$$ J_{pend} \ddot \theta + mgr\ sin(\theta) - mLr\ sin(\alpha-\theta)\dot \alpha^2 + mLr\ cos(\alpha - \theta)\ddot \theta + mr^2\ddot \theta = 0$$

$$J_{arm} \ddot \alpha + mL^2\ddot \alpha + mLr\ sin(\alpha - \theta)\dot \theta^2 + mLr\ cos(\alpha - \theta)\ddot \theta = 0   $$

Here, $\theta$ is the angle of the pendulum from the vertical axis, $\alpha$ is the angle of the arm from the horizontal axis, $L$ is the length of the pendulum, $m$ is the mass of the pendulum, $r$ is the distance of the pivot point from the center of mass of the pendulum, $J_{pend}$ is the moment of inertia of the pendulum about its center of mass and $J_{arm}$ is the moment of inertia of the arm.

### Linearization

Next, we linearize the system of equations. In our case, we want the pendulum to stay upright, so that would mean $\theta = \pi$ and additionally, we want $\alpha = 0$. Based on these conditions the linearized equations of motion would be:

For $\theta$:
$$J_{pend}\ddot \theta + gmr(\theta - \pi) + mr^2\ddot \theta = 0$$

For $\alpha$:
$$J_{arm}\ddot \alpha + L^2m\ddot \alpha - mLr(\alpha - \theta + \pi)\ddot \theta = 0 $$

### Designing the PID controller

PID control is a very straightforward approach to the problem, which works by adjusting the control output based on the proportional, integral and derivative terms of the error signal. It is a good way to quickly get the project off the ground and test basic functionality, and will provide sufficiently good results with relatively less effort. The most tedious part of this method is tuning the controller gains, and there are several methods to do this, including Ziegler-Nichols and Cohen-Coon.

Because we have two control inputs, $\theta$ and $\alpha$, we need two PID controllers, $c_{\theta}$ and $c_{\alpha}$.

The general form of the transfer function for these controllers would be:

$$C(s) = K_p + \frac{K_i}{s} + K_ds$$

Once we have good enough values for the controller gains, we now have a controller that can maintain the system at equilibrium.

<center><img src="/img/pid_small.gif" alt="RIP" height="400" width="400"></center> 

### Designing a state space controller

### PID vs state space controller

### Final thoughts

State space controllers are not the end of the road. There are superior ways to handle the errors and maintain equlibrium, including optimization-based approaches like the LQR method, which optimizes system performance by minimizing a predefined cost function.

[github repo](https://github.com/ashwath-karthikeyan/rotary-inverted-pendulum.git)